<%
let entityRelation = [];
entity.columns.forEach(column => {
    if (column.foreignKey) {
        entityRelation.push(ejsHelpers.snakeToCamel("'" + column.name.replace('_id', '') + "'"));
    }
});
%>
import { validate } from 'class-validator';
import { DeepPartial, Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { plainToInstance } from 'class-transformer';
import {
BadRequestException,
Injectable,
NotFoundException,
} from '@nestjs/common';
import { <%= entity.namePascalCase %> } from './entities/<%= entity.nameKebabCase %>.entity';
import { Create<%= entity.namePascalCase %>Dto } from './dto/create-<%= entity.nameKebabCase %>.dto';
import { Update<%= entity.namePascalCase %>Dto } from './dto/update-<%= entity.nameKebabCase %>.dto';

@Injectable()
export class <%= entity.namePascalCase %>Service {

constructor(
@InjectRepository(<%= entity.namePascalCase %>)
private readonly <%= entity.nameCamelCase %>Repository: Repository<<%= entity.namePascalCase %>>,
) {}

async findAll(): Promise<<%= entity.namePascalCase %>[]> {
return await this.<%= entity.nameCamelCase %>Repository.find({
<% if (entityRelation.length > 0) { %>
    relations: [<%- entityRelation.join(', ') %>],
<% } %>
});
}

async findOne(id: number): Promise<<%= entity.namePascalCase %>> {
<%#const numericId = parseInt(id, 10);%>
if (isNaN(id)) {
throw new BadRequestException(`Invalid ID format: ${id}`);
}
const item = await this.<%= entity.nameCamelCase %>Repository.findOne({
where: { id: id },
<% if (entityRelation.length > 0) { %>
    relations: [<%- entityRelation.join(', ') %>],
<% } %>
});
if (!item) {
throw new NotFoundException(`Item with ID ${id} not found`);
}
return item;
}

async create(create<%= entity.namePascalCase %>Dto: Create<%= entity.namePascalCase %>Dto): Promise<<%= entity.namePascalCase %>> {
const dtoInstance = plainToInstance(Create<%= entity.namePascalCase %>Dto, create<%= entity.namePascalCase %>Dto);
// Valider le DTO avant la crÃ©ation
const errors = await validate(dtoInstance);
if (errors.length > 0) {
throw new BadRequestException(errors);
}
const newItem = this.<%= entity.nameCamelCase %>Repository.create(
dtoInstance as DeepPartial<<%= entity.namePascalCase %>>,
);
return await this.<%= entity.nameCamelCase %>Repository.save(newItem);
}

async update(id: number, update<%= entity.namePascalCase %>Dto: Update<%= entity.namePascalCase %>Dto): Promise<<%= entity.namePascalCase %>> {
<%#const numericId = parseInt(id, 10);%>
if (isNaN(id)) {
throw new BadRequestException(`Invalid ID format: ${id}`);
}
const item = await this.<%= entity.nameCamelCase %>Repository.findOne({
where: { id: id },
});
if (!item) {
throw new NotFoundException(`Item with ID ${id} not found`);
}

Object.assign(item, update<%= entity.namePascalCase %>Dto);
return await this.<%= entity.nameCamelCase %>Repository.save(item);
}

async remove(id: number): Promise
<void> {
    <%#const numericId = parseInt(id, 10);%>
    if (isNaN(id)) {
    throw new BadRequestException(`Invalid ID format: ${id}`);
    }
    const item = await this.<%= entity.nameCamelCase %>Repository.findOne({
    where: { id: id },
    });
    if (!item) {
    throw new NotFoundException(`Item with ID ${id} not found`);
    }
    await this.<%= entity.nameCamelCase %>Repository.remove(item);
    }
    }